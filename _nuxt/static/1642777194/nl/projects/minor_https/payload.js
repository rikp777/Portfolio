__NUXT_JSONP__("/nl/projects/minor_https", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax,ay,az,aA,aB,aC,aD,aE,aF,aG,aH,aI,aJ,aK,aL,aM,aN,aO,aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY){aa.slug=ab;aa.description="What is https and how does it work.";aa.title=ac;aa.duration="3 day";aa.image="\u002Fimages\u002Fprojects\u002Fminor\u002Fethics\u002Fmain.jpg";aa.tech=[{name:"web"},{name:U}];aa.category=[{name:"minor"},{name:"cyber"},{name:"body of knowledge"}];aa.author={name:"Rik Peeters",image:"\u002Fimages\u002Fme.jpg",social:{twitter:"rikp777"}};aa.createdAt="2022-01-20T00:00:00.000Z";aa.toc=[{id:ad,depth:B,text:ae},{id:af,depth:B,text:ag},{id:ah,depth:M,text:ai},{id:aj,depth:M,text:ak},{id:al,depth:B,text:am},{id:an,depth:B,text:ao},{id:ap,depth:B,text:aq},{id:ar,depth:M,text:as},{id:at,depth:M,text:au}];aa.body={type:"root",children:[{type:a,tag:av,props:{id:U},children:[{type:a,tag:h,props:{href:"#https",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ac}]},{type:b,value:d},{type:a,tag:C,props:{id:ad},children:[{type:a,tag:h,props:{href:"#encryption",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ae}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Encryption is a technique for encrypting data so that only authorized parties may decipher it. It is the process of transforming human-readable plaintext to unintelligible text, also known as ciphertext, in technical terms. Encryption, to put it another way, takes legible data and makes it look random. Encryption necessitates the employment of a cryptographic key, which is a set of mathematical values agreed upon by both the sender and receiver of an encrypted communication."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Symmetric encryption and asymmetric encryption are the two primary types of encryption. Public key encryption is another name for asymmetric encryption."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"There is just one key in symmetric encryption, and all communication parties utilize the same (secret) key for encryption and decryption. There are two keys in asymmetric, or public key, encryption: one is used for encryption, and the other is used for decryption."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"The decryption key is kept secret (thus the name \"private key\"), while the encryption key is released publicly and can be used by anybody (hence the \"public key\" name). Asymmetric encryption is a key component of TLS (also known as SSL)."}]},{type:b,value:d},{type:a,tag:C,props:{id:af},children:[{type:a,tag:h,props:{href:"#http-with-ssltls",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ag}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Https is just like http, but it has some SSL\u002FTLS encryption on top of it all. It's what nowadays keeps your passwords, credit card details and general communication safe between you the user and the server your accessing. SSL has to two main purposes:"}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"Its verifies that you're indeed talking directly to the server that you want to communicate with."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"It ensures that only the server can read the data your communicating between each other."}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"A SSL connection between the client and the server is set up by using a handshake. This handshake has three goals."}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"It communicated to agree which encryption algorithm to use to communicate."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"It communicates the secret key to be used for encryption."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"It verifies that the communication is made with the right server this happens both ways."}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Once the connection is established, both parties can use the agreed algorithm and keys to securely send messages to each other. During a handshake a couple of steps happen explained below."}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL client send a \"client hello\" message. This message with include cryptographic information such as the SSL or TLS version and a random byte string. It also includes the CipherSuites supported by the client."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL server responds with a \"server hello\" message. With the information send from the client the server decides which CipherSuite version to use. Than the server sends a digital certificate to prove its identity to the client. The certificate contains data that includes the name of the owner, the domain, the certificate's public key, certificate validity dates."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL client verifies the server's digital certificate. The client checks that it either implicitly trusts the certificate, or that it is verified and trusted by one of several Certificate Authorities (CAs) that it also implicitly trusts. The client than sends the random byte string that enables both the client and the server to compute the secret key to be used for encrypting data. The random byte string itself is encrypted with the server's public key. The encryption of the actual message data exchanged by the client and server will be done using a symmetric algorithm, the exact nature of which was already agreed during the Hello phase. A symmetric algorithm uses a single key for both encryption and decryption, in contrast to asymmetric algorithms that require a public\u002Fprivate key pair. Both parties need to agree on this single, symmetric key, a process that is accomplished securely using asymmetric encryption and the server’s public\u002Fprivate keys."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL Server send a \"client certificate request\". The client sends a random byte string encrypted with the private key of the client, together with the clients digital certificate, or a \"no digital certificate alert\". This alert is only a warning, but with some implementation the handshake fails if client authentication is mandatory."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL client sends a request to the server a \"finished\" message. This request is encrypted with the secret key."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"The SSL\u002FTSL server also send a request to the client, also a \"finished\" message."}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:D,props:{target:z,rel:[E,b],to:aw},children:[{type:b,value:F},{type:a,tag:G,props:{width:H,src:aw,alt:U},children:[]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:I,props:{id:ah},children:[{type:a,tag:h,props:{href:"#open-wifi-monitoring-traffic",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ai}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"The company of which you are using a connection to the internet from can watch every single byte of data you're exchanging between you and the server, but they can not read what you're sending and receiving. They can only monitor the amount off data you're sending\u002Freceiving. But there are workarounds to trick the user in using just a plain HTTP connection over a HTTPS. But most browsers nowaday will notify the user if done so."}]},{type:b,value:d},{type:a,tag:I,props:{id:aj},children:[{type:a,tag:h,props:{href:"#work-moniting-traffic",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ak}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"If you're utilizing a machine that's managed by your organization. Remember that an implicitly trusted CA is at the heart of every chain of trust, and that your browser stores a list of these authorities. Your organization might utilize your computer to add their own self-signed certificate to this list of CAs. They might then intercept all of your HTTPS requests and deliver certificates purporting to represent the proper website, certified by their fake-CA and so trusted by your browser without no other validation."}]},{type:b,value:d},{type:a,tag:C,props:{id:al},children:[{type:a,tag:h,props:{href:"#ciphersuite",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:am}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"The use of SSL extends beyond simply installing the SSL certificate; server configurations are also important. The cipher suites are an important part of these server configurations."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"A cipher suite is a technique for establishing a secure connection in accordance with the TLS protocol. The TLS protocol is based on a complex set of algorithms that are used to secure communication between a server and a user. An algorithm is a set of instructions for doing a task, where the input performs a set of outputs after a certain number of steps."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"A cipher suite describes how data is sent and processed between a server and a client. A cipher suite includes, for example,"}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"ECDHE RSA is a key exchange algorithm that specifies how authentication takes place during the SSL handshake."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"AES 128 GCM, for example, is an encryption algorithm that specifies how the unencrypted data is sent."}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"a cryptographic hashing algorithm, such as SHA-256, for encrypting unencrypted data."}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:av,props:{id:"encryption-algorithms"},children:[{type:a,tag:h,props:{href:"#encryption-algorithms",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:"Encryption algorithms?"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Some important element of a encryption standart it should be open scource so that there's no reliance on security through obscurity and to make sure that there's no backdoor weaknesses that are built into the encryption to be maliciously taken advantage of."}]},{type:b,value:d},{type:a,tag:C,props:{id:an},children:[{type:a,tag:h,props:{href:"#commonly-used-symmetric-encryption-algorithms-include",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ao}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"AES"}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"3-DES"}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"SNOW"}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Commonly used asymmetric encryption algorithms include:"}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"RSA"}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"Elliptic curve cryptography"}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:C,props:{id:ap},children:[{type:a,tag:h,props:{href:"#aes---advanced-encryption-standard",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:aq}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Brief history created in 1997 because the gov had to create a newer more secure encryption algorithm. 15 people submitted their secure algorithm, one year later 1999 they had only 5 algorithms left after selection. In 2000 Rijndael was chosen as the AES. The name based on the two creaters Joan Daemen and Vincent Rijmen."}]},{type:b,value:d},{type:a,tag:I,props:{id:ar},children:[{type:a,tag:h,props:{href:"#how-does-aeswork",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:as}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"AES is a 128 bit symmetric block cipher, that means it takes 128 bits of message and it encrypts it into 128 bits of ciphertext with some key. That key can either be 128, 192 or 256 bits, this gives varying amounts of security because the larger the key the higher the incryption. But large keys also mean larger encryption and descryption times. To put this in perspective you could have 10 million computers that are all geussing 10 trillion different keys per second and it would still take them 107 billion years to guess every possible combination. So 128 bit is already pretty secure."}]},{type:b,value:d},{type:a,tag:D,props:{target:z,rel:[E,b],to:ax},children:[{type:b,value:F},{type:a,tag:G,props:{width:H,src:ax,alt:N},children:[]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:w,props:{id:"block-devision"},children:[{type:a,tag:h,props:{href:"#block-devision",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:"Block devision"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"What AES does when it ecrypts data it converts your data in hex or binary. This because either one if farily easy write and read. The data is than split into 128 bit blocks that have four rows and four columns and each entry is going to be two of thos hex characters which each represents one byte so a block is 16 bytes in total or 128bits. There're eight bits in a byte and 16 x 8 = 128)"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"If you message was \"I want to get a good for this semester hihi\""}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Block one:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:O}]},{type:a,tag:f,props:{},children:[{type:b,value:P}]},{type:a,tag:f,props:{},children:[{type:b,value:x}]},{type:a,tag:f,props:{},children:[{type:b,value:u}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:Q}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:V}]},{type:a,tag:c,props:{},children:[{type:b,value:h}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:h}]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]},{type:a,tag:c,props:{},children:[]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Block two:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:V}]},{type:a,tag:f,props:{},children:[]},{type:a,tag:f,props:{},children:[]},{type:a,tag:f,props:{},children:[{type:b,value:J}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:x}]},{type:a,tag:c,props:{},children:[{type:b,value:"f"}]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:x}]},{type:a,tag:c,props:{},children:[{type:b,value:x}]},{type:a,tag:c,props:{},children:[{type:b,value:W}]},{type:a,tag:c,props:{},children:[{type:b,value:J}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"d"}]},{type:a,tag:c,props:{},children:[{type:b,value:R}]},{type:a,tag:c,props:{},children:[{type:b,value:X}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Block three:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:Y}]},{type:a,tag:f,props:{},children:[{type:b,value:t}]},{type:a,tag:f,props:{},children:[{type:b,value:X}]},{type:a,tag:f,props:{},children:[]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:t}]},{type:a,tag:c,props:{},children:[{type:b,value:R}]},{type:a,tag:c,props:{},children:[{type:b,value:W}]},{type:a,tag:c,props:{},children:[]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:J}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:X}]},{type:a,tag:c,props:{},children:[]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[{type:b,value:W}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]}]}]}]},{type:b,value:d},{type:a,tag:w,props:{id:"key-expansion"},children:[{type:a,tag:h,props:{href:"#key-expansion",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:ay}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Key expansion involves taking the initial key and using it to come up with a series of other keys for each round of the encryption process. These new 128-bit round keys are derived with"},{type:a,tag:h,props:{href:"http:\u002F\u002Fwww.samiam.org\u002Fkey-schedule.html",rel:["nofollow","noopener","noreferrer"],target:z},children:[{type:b,value:" Rijndael’s key schedule"}]},{type:b,value:", which is essentially a simple and fast way to produce new key ciphers. If the initial key was “I want some beer”"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:O}]},{type:a,tag:f,props:{},children:[{type:b,value:P}]},{type:a,tag:f,props:{},children:[{type:b,value:x}]},{type:a,tag:f,props:{},children:[{type:b,value:az}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[{type:b,value:Y}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:Q}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:t}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:h}]},{type:a,tag:c,props:{},children:[{type:b,value:J}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:R}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Then each of the new keys might look something like this once Rijndael’s key schedule has been used:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:"14"}]},{type:a,tag:f,props:{},children:[{type:b,value:"29"}]},{type:a,tag:f,props:{},children:[{type:b,value:"1h"}]},{type:a,tag:f,props:{},children:[{type:b,value:aA}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"h9"}]},{type:a,tag:c,props:{},children:[{type:b,value:aB}]},{type:a,tag:c,props:{},children:[{type:b,value:"st"}]},{type:a,tag:c,props:{},children:[{type:b,value:aB}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"gt"}]},{type:a,tag:c,props:{},children:[{type:b,value:"2h"}]},{type:a,tag:c,props:{},children:[{type:b,value:"hq"}]},{type:a,tag:c,props:{},children:[{type:b,value:"73"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"ks"}]},{type:a,tag:c,props:{},children:[{type:b,value:Z}]},{type:a,tag:c,props:{},children:[{type:b,value:"df"}]},{type:a,tag:c,props:{},children:[{type:b,value:"hb"}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Although they look like random characters (and the above example is just made up) each of these keys is derived from a structured process when AES encryption is actually applied."}]},{type:b,value:d},{type:a,tag:w,props:{id:"add-round-key"},children:[{type:a,tag:h,props:{href:"#add-round-key",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:S}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"In this step, because it is the first round, our initial key is added to the block of our message:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:O}]},{type:a,tag:f,props:{},children:[{type:b,value:P}]},{type:a,tag:f,props:{},children:[{type:b,value:x}]},{type:a,tag:f,props:{},children:[{type:b,value:u}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:Q}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:V}]},{type:a,tag:c,props:{},children:[{type:b,value:h}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:h}]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]},{type:a,tag:c,props:{},children:[]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"combined with"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:O}]},{type:a,tag:f,props:{},children:[{type:b,value:P}]},{type:a,tag:f,props:{},children:[{type:b,value:x}]},{type:a,tag:f,props:{},children:[{type:b,value:az}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:u}]},{type:a,tag:c,props:{},children:[{type:b,value:Y}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:Q}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:t}]},{type:a,tag:c,props:{},children:[{type:b,value:t}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:h}]},{type:a,tag:c,props:{},children:[{type:b,value:J}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:R}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"This is done with an XOR cipher, which is an additive encryption algorithm. While it looks like you can’t actually add these things together, be aware that it is actually done in binary. The characters are just a stand-in to try and make things easier to understand. Let’s say that this mathematical operation gives us a result of:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:I}]},{type:a,tag:f,props:{},children:[{type:b,value:Z}]},{type:a,tag:f,props:{},children:[{type:b,value:"zu"}]},{type:a,tag:f,props:{},children:[{type:b,value:aA}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"s8"}]},{type:a,tag:c,props:{},children:[{type:b,value:"7d"}]},{type:a,tag:c,props:{},children:[{type:b,value:"15"}]},{type:a,tag:c,props:{},children:[{type:b,value:"2k"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:Z}]},{type:a,tag:c,props:{},children:[{type:b,value:"4b"}]},{type:a,tag:c,props:{},children:[{type:b,value:A}]},{type:a,tag:c,props:{},children:[{type:b,value:"2s"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"74"}]},{type:a,tag:c,props:{},children:[{type:b,value:"el"}]},{type:a,tag:c,props:{},children:[{type:b,value:"k1"}]},{type:a,tag:c,props:{},children:[{type:b,value:"hd"}]}]}]}]},{type:b,value:d},{type:a,tag:w,props:{id:"substitute-bytes"},children:[{type:a,tag:h,props:{href:"#substitute-bytes",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:"Substitute bytes"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Each byte is replaced according to a specified table in this stage. This is similar to the example at the beginning of the article, when the statement was coded by changing each letter in the alphabet to the one following it (hello becomes ifmmp). Provides confusion."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"This system is a little more sophisticated and does not always follow a logical pattern. Instead, the algorithm can consult a known table. Let's suppose that after this step, the preset table yields:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:aC}]},{type:a,tag:f,props:{},children:[{type:b,value:aD}]},{type:a,tag:f,props:{},children:[{type:b,value:aE}]},{type:a,tag:f,props:{},children:[{type:b,value:aF}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:A}]},{type:a,tag:c,props:{},children:[{type:b,value:aG}]},{type:a,tag:c,props:{},children:[{type:b,value:aH}]},{type:a,tag:c,props:{},children:[{type:b,value:aI}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:aJ}]},{type:a,tag:c,props:{},children:[{type:b,value:A}]},{type:a,tag:c,props:{},children:[{type:b,value:aK}]},{type:a,tag:c,props:{},children:[{type:b,value:aL}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:aM}]},{type:a,tag:c,props:{},children:[{type:b,value:aN}]},{type:a,tag:c,props:{},children:[{type:b,value:aO}]},{type:a,tag:c,props:{},children:[{type:b,value:aP}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"A bytes become B bytes trough S"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"The Byte Substitution layer consists of 16 S-Boxes with the following properties:"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"The S-Boxes are"}]},{type:b,value:d},{type:a,tag:v,props:{},children:[{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"identical"}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"the only nonlinear elements of AES, i.e., ByteSub(Ai) + ByteSub(Aj) ≠ ByteSub(Ai + Aj), for i,j = 0,…,15"}]},{type:b,value:d},{type:a,tag:i,props:{},children:[{type:b,value:"bijective, i.e., there exists a one-to-one mapping of input and output bytes ⇒ S-Box can be uniquely reversed"}]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"In software implementations, the S-Box is usually realized as a lookup table"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Example s-box table:"}]},{type:b,value:d},{type:a,tag:D,props:{target:z,rel:[E,b],to:aQ},children:[{type:b,value:F},{type:a,tag:G,props:{width:H,src:aQ,alt:N},children:[]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:w,props:{id:"shift-rows"},children:[{type:a,tag:h,props:{href:"#shift-rows",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:_}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Shift rows is a simple term, and this step is pretty much what you'd anticipate. The second row has been shifted one place to the left, the third row has been shifted two spaces to the left, and the fourth row has been shifted three spaces to the left. This gives us the following:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:aC}]},{type:a,tag:f,props:{},children:[{type:b,value:aD}]},{type:a,tag:f,props:{},children:[{type:b,value:aE}]},{type:a,tag:f,props:{},children:[{type:b,value:aF}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:aG}]},{type:a,tag:c,props:{},children:[{type:b,value:aH}]},{type:a,tag:c,props:{},children:[{type:b,value:aI}]},{type:a,tag:c,props:{},children:[{type:b,value:A}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:aK}]},{type:a,tag:c,props:{},children:[{type:b,value:aL}]},{type:a,tag:c,props:{},children:[{type:b,value:aJ}]},{type:a,tag:c,props:{},children:[{type:b,value:A}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:aP}]},{type:a,tag:c,props:{},children:[{type:b,value:aO}]},{type:a,tag:c,props:{},children:[{type:b,value:aN}]},{type:a,tag:c,props:{},children:[{type:b,value:aM}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"first row stays:\nsecond row shifts: one\nthirth row shifts: two\nfourth row shifts: three"}]},{type:b,value:d},{type:a,tag:w,props:{id:"mix-columns"},children:[{type:a,tag:h,props:{href:"#mix-columns",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:aR}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"This stage is a little more difficult to describe. Let's simply pretend that each column has a mathematical equation applied to it to further dilute it, to strip out much of the arithmetic and simplify things. Let's imagine the operation yields the following result:"}]},{type:b,value:s},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:"dk"}]},{type:a,tag:f,props:{},children:[{type:b,value:"l3"}]},{type:a,tag:f,props:{},children:[{type:b,value:"d8"}]},{type:a,tag:f,props:{},children:[{type:b,value:"23"}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"al"}]},{type:a,tag:c,props:{},children:[{type:b,value:A}]},{type:a,tag:c,props:{},children:[{type:b,value:"so"}]},{type:a,tag:c,props:{},children:[{type:b,value:"d1"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"cn"}]},{type:a,tag:c,props:{},children:[{type:b,value:"kd"}]},{type:a,tag:c,props:{},children:[{type:b,value:"4m"}]},{type:a,tag:c,props:{},children:[{type:b,value:"n3"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:"32"}]},{type:a,tag:c,props:{},children:[{type:b,value:"g9"}]},{type:a,tag:c,props:{},children:[{type:b,value:"kw"}]},{type:a,tag:c,props:{},children:[{type:b,value:"hr"}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Matrix multiplication: lets say we have:"}]},{type:b,value:"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{type:a,tag:p,props:{},children:[{type:a,tag:q,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:f,props:{},children:[{type:b,value:T}]},{type:a,tag:f,props:{},children:[{type:b,value:K}]},{type:a,tag:f,props:{},children:[{type:b,value:y}]},{type:a,tag:f,props:{},children:[{type:b,value:y}]},{type:a,tag:f,props:{},children:[]},{type:a,tag:f,props:{},children:[{type:b,value:"c0"}]}]}]},{type:a,tag:r,props:{},children:[{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:y}]},{type:a,tag:c,props:{},children:[{type:b,value:K}]},{type:a,tag:c,props:{},children:[{type:b,value:K}]},{type:a,tag:c,props:{},children:[{type:b,value:y}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:"c1"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:y}]},{type:a,tag:c,props:{},children:[{type:b,value:T}]},{type:a,tag:c,props:{},children:[{type:b,value:T}]},{type:a,tag:c,props:{},children:[{type:b,value:K}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:"c2"}]}]},{type:a,tag:g,props:{},children:[{type:a,tag:c,props:{},children:[{type:b,value:K}]},{type:a,tag:c,props:{},children:[{type:b,value:y}]},{type:a,tag:c,props:{},children:[{type:b,value:y}]},{type:a,tag:c,props:{},children:[{type:b,value:T}]},{type:a,tag:c,props:{},children:[]},{type:a,tag:c,props:{},children:[{type:b,value:"c3"}]}]}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"row 1 * c0 + row 2 * c1 + row 3 * c2 + row 4 + c3 ="}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Reordering bytes trough mixcolboxes"}]},{type:b,value:d},{type:a,tag:w,props:{id:"add-round-key-again"},children:[{type:a,tag:h,props:{href:"#add-round-key-again",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:"Add round key (again)"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"Remember how we produced those circular keys at the beginning with our initial key and Rijndael's key schedule? This is where we begin to employ them. We add the first round key we obtained to the result of our mixed columns"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"But that not all it doesn't  stop there. At the start it was mentioned that there are different sizes that can be applied. Either 128, 192 or 256 bits. When we use a 128 bits key. The encryption will use nine round after each other. When a 192 bit key is used this will be eleven rounds. Wen a 256 bit key is used there will be 14 rounds."}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:L,props:{},children:[{type:b,value:"To make things clearer, the entire AES encryption process goes:"}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:ay}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:S}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aS}]},{type:b,value:" (provides confusion)"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:_}]},{type:b,value:"  (provides diffusion)"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aR}]},{type:b,value:" (provides diffusion)"}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:S}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:"x 9, 11 or 14 times, depending on whether the key is 128, 192 or 256-bit"}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aS}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:_}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:S}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"After the data has gone through this complicated procedure, my initial \"I want to get a good for this semester hihi\" becomes \"38kwo3jgnsuwfhc6pncxl35vs\""}]},{type:b,value:d},{type:a,tag:I,props:{id:at},children:[{type:a,tag:h,props:{href:"#decrypting-aes",ariaHidden:k,tabIndex:l},children:[{type:a,tag:m,props:{className:[n,o]},children:[]}]},{type:b,value:au}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"If we start with our encrypted result of "},{type:a,tag:L,props:{},children:[{type:b,value:aT}]},{type:b,value:" and "},{type:a,tag:L,props:{},children:[{type:b,value:"apply the inverse of each encryption step"}]},{type:b,value:", it starts with the inverse round key, then the inverse shift rows, and the inverse byte substitution, before going into the inverse of the 9, 11 or 14 rounds. "},{type:a,tag:L,props:{},children:[{type:b,value:"It looks like this:"}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:aT}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:$}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aU}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aV}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:$}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:"Inverse mix columns"}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aU}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:aV}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:"x 9, 11 or 14 times, depending on whether the key is 128,192 or 256-bit"}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:a,tag:j,props:{},children:[{type:b,value:$}]}]},{type:b,value:d},{type:a,tag:e,props:{},children:[{type:b,value:"After this decryption process, we end up with our original message again: "},{type:a,tag:L,props:{},children:[{type:b,value:"“I want to get a good for this semester hihi”"}]}]},{type:b,value:d},{type:a,tag:"div",props:{className:["nuxt-content-highlight"]},children:[{type:a,tag:"pre",props:{className:["language-text","line-numbers"]},children:[{type:a,tag:"code",props:{},children:[{type:b,value:"function AESencrypt(plaintext, key) {\n  \n  blocks := divideIntoBlocks(plaintext);\n  roundKeys = getRoundKeys(key)\n  for (block in blocks) {\n    \u002F\u002Ffirst round\n    addRoundKey(roundKeys[0], block);\n    \u002F\u002Fintermediate rounds\n    for (8, 10 or 12 rounds) {\n      subBytes(block);\n      shiftRows(block);\n      mixColumns(block);\n      addRoundKey(roundKeys[..], block);\n    }\n    \u002F\u002Flast round\n    subBytes(block);\n    shiftRows(block);\n    addRoundKey(roundKeys[numRounds - 1], block);\n  }\n  ciphertext := reassemble(blocks);\n  return ciphertext;\n}\n"}]}]}]},{type:b,value:d},{type:a,tag:D,props:{target:z,rel:[E,b],to:aW},children:[{type:b,value:F},{type:a,tag:G,props:{width:H,src:aW,alt:N},children:[]},{type:b,value:d}]},{type:b,value:d},{type:a,tag:D,props:{target:z,rel:[E,b],to:"\u002Fimages\u002Fprojects\u002Fminor\u002Ffuntion_for_rounds.png"},children:[{type:b,value:F},{type:a,tag:G,props:{width:H,src:"\u002Fimages\u002Fprojects\u002Fminor\u002Ffunction_for_rounds.png",alt:N},children:[]},{type:b,value:d}]}]};aa.dir="\u002Fprojects\u002Fminor";aa.path="\u002Fprojects\u002Fminor\u002Fhttps";aa.extension=".md";aa.updatedAt="2022-01-21T14:57:29.933Z";aa.bodyPlainText="\n# HTTPS\n\n## Encryption \n\nEncryption is a technique for encrypting data so that only authorized parties may decipher it. It is the process of transforming human-readable plaintext to unintelligible text, also known as ciphertext, in technical terms. Encryption, to put it another way, takes legible data and makes it look random. Encryption necessitates the employment of a cryptographic key, which is a set of mathematical values agreed upon by both the sender and receiver of an encrypted communication.\n\nSymmetric encryption and asymmetric encryption are the two primary types of encryption. Public key encryption is another name for asymmetric encryption.\n\nThere is just one key in symmetric encryption, and all communication parties utilize the same (secret) key for encryption and decryption. There are two keys in asymmetric, or public key, encryption: one is used for encryption, and the other is used for decryption.\n\nThe decryption key is kept secret (thus the name \"private key\"), while the encryption key is released publicly and can be used by anybody (hence the \"public key\" name). Asymmetric encryption is a key component of TLS (also known as SSL).\n\n## Http with SSL\u002FTLS\n\nHttps is just like http, but it has some SSL\u002FTLS encryption on top of it all. It's what nowadays keeps your passwords, credit card details and general communication safe between you the user and the server your accessing. SSL has to two main purposes:\n\n- Its verifies that you're indeed talking directly to the server that you want to communicate with.\n- It ensures that only the server can read the data your communicating between each other.\n\nA SSL connection between the client and the server is set up by using a handshake. This handshake has three goals. \n\n- It communicated to agree which encryption algorithm to use to communicate. \n- It communicates the secret key to be used for encryption.\n- It verifies that the communication is made with the right server this happens both ways. \n\nOnce the connection is established, both parties can use the agreed algorithm and keys to securely send messages to each other. During a handshake a couple of steps happen explained below. \n\n- The SSL\u002FTSL client send a \"client hello\" message. This message with include cryptographic information such as the SSL or TLS version and a random byte string. It also includes the CipherSuites supported by the client. \n- The SSL\u002FTSL server responds with a \"server hello\" message. With the information send from the client the server decides which CipherSuite version to use. Than the server sends a digital certificate to prove its identity to the client. The certificate contains data that includes the name of the owner, the domain, the certificate's public key, certificate validity dates.   \n- The SSL\u002FTSL client verifies the server's digital certificate. The client checks that it either implicitly trusts the certificate, or that it is verified and trusted by one of several Certificate Authorities (CAs) that it also implicitly trusts. The client than sends the random byte string that enables both the client and the server to compute the secret key to be used for encrypting data. The random byte string itself is encrypted with the server's public key. The encryption of the actual message data exchanged by the client and server will be done using a symmetric algorithm, the exact nature of which was already agreed during the Hello phase. A symmetric algorithm uses a single key for both encryption and decryption, in contrast to asymmetric algorithms that require a public\u002Fprivate key pair. Both parties need to agree on this single, symmetric key, a process that is accomplished securely using asymmetric encryption and the server’s public\u002Fprivate keys.\n- The SSL\u002FTSL Server send a \"client certificate request\". The client sends a random byte string encrypted with the private key of the client, together with the clients digital certificate, or a \"no digital certificate alert\". This alert is only a warning, but with some implementation the handshake fails if client authentication is mandatory. \n- The SSL\u002FTSL client sends a request to the server a \"finished\" message. This request is encrypted with the secret key. \n- The SSL\u002FTSL server also send a request to the client, also a \"finished\" message. \n\n\u003Ca href=\"\u002Fimages\u002Fprojects\u002Fminor\u002FHTTPS.gif\" target=\"_blank\" rel=\"some text\"\u003E\n  \u003Cimg width=\"80%\" src=\"\u002Fimages\u002Fprojects\u002Fminor\u002FHTTPS.gif\" alt=\"https\"\u002F\u003E\n\u003C\u002Fa\u003E\n\n### Open Wifi monitoring traffic\n\nThe company of which you are using a connection to the internet from can watch every single byte of data you're exchanging between you and the server, but they can not read what you're sending and receiving. They can only monitor the amount off data you're sending\u002Freceiving. But there are workarounds to trick the user in using just a plain HTTP connection over a HTTPS. But most browsers nowaday will notify the user if done so. \n\n### Work moniting traffic \n\nIf you're utilizing a machine that's managed by your organization. Remember that an implicitly trusted CA is at the heart of every chain of trust, and that your browser stores a list of these authorities. Your organization might utilize your computer to add their own self-signed certificate to this list of CAs. They might then intercept all of your HTTPS requests and deliver certificates purporting to represent the proper website, certified by their fake-CA and so trusted by your browser without no other validation.\n\n## CipherSuite \n\nThe use of SSL extends beyond simply installing the SSL certificate; server configurations are also important. The cipher suites are an important part of these server configurations.\n\nA cipher suite is a technique for establishing a secure connection in accordance with the TLS protocol. The TLS protocol is based on a complex set of algorithms that are used to secure communication between a server and a user. An algorithm is a set of instructions for doing a task, where the input performs a set of outputs after a certain number of steps.\n\nA cipher suite describes how data is sent and processed between a server and a client. A cipher suite includes, for example,\n\n- ECDHE RSA is a key exchange algorithm that specifies how authentication takes place during the SSL handshake.\n- AES 128 GCM, for example, is an encryption algorithm that specifies how the unencrypted data is sent.\n- a cryptographic hashing algorithm, such as SHA-256, for encrypting unencrypted data.\n\n# Encryption algorithms?\n\nSome important element of a encryption standart it should be open scource so that there's no reliance on security through obscurity and to make sure that there's no backdoor weaknesses that are built into the encryption to be maliciously taken advantage of.\n\n## Commonly used symmetric encryption algorithms include:\n\n- AES\n- 3-DES\n- SNOW\n\nCommonly used asymmetric encryption algorithms include:\n\n- RSA\n- Elliptic curve cryptography\n\n## AES - Advanced Encryption Standard\n\nBrief history created in 1997 because the gov had to create a newer more secure encryption algorithm. 15 people submitted their secure algorithm, one year later 1999 they had only 5 algorithms left after selection. In 2000 Rijndael was chosen as the AES. The name based on the two creaters Joan Daemen and Vincent Rijmen. \n\n### How does AESwork\n\nAES is a 128 bit symmetric block cipher, that means it takes 128 bits of message and it encrypts it into 128 bits of ciphertext with some key. That key can either be 128, 192 or 256 bits, this gives varying amounts of security because the larger the key the higher the incryption. But large keys also mean larger encryption and descryption times. To put this in perspective you could have 10 million computers that are all geussing 10 trillion different keys per second and it would still take them 107 billion years to guess every possible combination. So 128 bit is already pretty secure. \n\n\u003Ca href=\"\u002Fimages\u002Fprojects\u002Fminor\u002Fprocess.png\" target=\"_blank\" rel=\"some text\"\u003E\n  \u003Cimg width=\"80%\" src=\"\u002Fimages\u002Fprojects\u002Fminor\u002Fprocess.png\" alt=\"aes\"\u002F\u003E\n\u003C\u002Fa\u003E\n\n#### Block devision\n\nWhat AES does when it ecrypts data it converts your data in hex or binary. This because either one if farily easy write and read. The data is than split into 128 bit blocks that have four rows and four columns and each entry is going to be two of thos hex characters which each represents one byte so a block is 16 bytes in total or 128bits. There're eight bits in a byte and 16 x 8 = 128)\n\nIf you message was \"I want to get a good for this semester hihi\"\n\nBlock one:\n\n| I    | n    | o    | t    |\n| ---- | ---- | ---- | ---- |\n|      | t    |      |      |\n| w    |      | g    | a    |\n| a    | t    | e    |      |\n\nBlock two:\n\n| g    |      |      | s    |\n| ---- | ---- | ---- | ---- |\n| o    | f    | t    |      |\n| o    | o    | h    | s    |\n| d    | r    | i    | e    |\n\nBlock three:\n\n| m    | e    | i    |      |\n| ---- | ---- | ---- | ---- |\n| e    | r    | h    |      |\n| s    |      | i    |      |\n| t    | h    |      |      |\n\n#### Key expansion\n\nKey expansion involves taking the initial key and using it to come up with a series of other keys for each round of the encryption process. These new 128-bit round keys are derived with[ Rijndael’s key schedule](http:\u002F\u002Fwww.samiam.org\u002Fkey-schedule.html), which is essentially a simple and fast way to produce new key ciphers. If the initial key was “I want some beer”\n\n| I    | n    | o    | b    |\n| ---- | ---- | ---- | ---- |\n|      | t    | m    | e    |\n| w    |      | e    | e    |\n| a    | s    |      | r    |\n\nThen each of the new keys might look something like this once Rijndael’s key schedule has been used:\n\n| 14   | 29   | 1h   | s5   |\n| ---- | ---- | ---- | ---- |\n| h9   | 9f   | st   | 9f   |\n| gt   | 2h   | hq   | 73   |\n| ks   | dj   | df   | hb   |\n\nAlthough they look like random characters (and the above example is just made up) each of these keys is derived from a structured process when AES encryption is actually applied.\n\n#### Add round key\n\nIn this step, because it is the first round, our initial key is added to the block of our message:\n\n| I    | n    | o    | t    |\n| ---- | ---- | ---- | ---- |\n|      | t    |      |      |\n| w    |      | g    | a    |\n| a    | t    | e    |      |\n\ncombined with \n\n| I    | n    | o    | b    |\n| ---- | ---- | ---- | ---- |\n|      | t    | m    | e    |\n| w    |      | e    | e    |\n| a    | s    |      | r    |\n\nThis is done with an XOR cipher, which is an additive encryption algorithm. While it looks like you can’t actually add these things together, be aware that it is actually done in binary. The characters are just a stand-in to try and make things easier to understand. Let’s say that this mathematical operation gives us a result of:\n\n| h3   | dj   | zu   | s5   |\n| ---- | ---- | ---- | ---- |\n| s8   | 7d   | 15   | 2k   |\n| dj   | 4b   | d2   | 2s   |\n| 74   | el   | k1   | hd   |\n\n#### Substitute bytes\n\n Each byte is replaced according to a specified table in this stage. This is similar to the example at the beginning of the article, when the statement was coded by changing each letter in the alphabet to the one following it (hello becomes ifmmp). Provides confusion.\n\nThis system is a little more sophisticated and does not always follow a logical pattern. Instead, the algorithm can consult a known table. Let's suppose that after this step, the preset table yields:\n\n| as   | ls   | sl   | l2   |\n| ---- | ---- | ---- | ---- |\n| d2   | 0s   | 1k   | ao   |\n| l1   | d2   | dn   | lf   |\n| 54   | 6l   | 19   | mn   |\n\nA bytes become B bytes trough S \n\nThe Byte Substitution layer consists of 16 S-Boxes with the following properties: \n\nThe S-Boxes are \n\n- identical \n- the only nonlinear elements of AES, i.e., ByteSub(Ai) + ByteSub(Aj) ≠ ByteSub(Ai + Aj), for i,j = 0,…,15 \n- bijective, i.e., there exists a one-to-one mapping of input and output bytes ⇒ S-Box can be uniquely reversed\n\nIn software implementations, the S-Box is usually realized as a lookup table\n\nExample s-box table:\n\n\u003Ca href=\"\u002Fimages\u002Fprojects\u002Fminor\u002Fs-box-table.png\" target=\"_blank\" rel=\"some text\"\u003E\n  \u003Cimg width=\"80%\" src=\"\u002Fimages\u002Fprojects\u002Fminor\u002Fs-box-table.png\" alt=\"aes\"\u002F\u003E\n\u003C\u002Fa\u003E\n\n#### Shift rows\n\nShift rows is a simple term, and this step is pretty much what you'd anticipate. The second row has been shifted one place to the left, the third row has been shifted two spaces to the left, and the fourth row has been shifted three spaces to the left. This gives us the following:\n\n| as   | ls   | sl   | l2   |\n| ---- | ---- | ---- | ---- |\n| 0s   | 1k   | ao   | d2   |\n| dn   | lf   | l1   | d2   |\n| mn   | 19   | 6l   | 54   |\n\nfirst row stays: \nsecond row shifts: one \nthirth row shifts: two \nfourth row shifts: three\n\n\n\n#### Mix columns\n\nThis stage is a little more difficult to describe. Let's simply pretend that each column has a mathematical equation applied to it to further dilute it, to strip out much of the arithmetic and simplify things. Let's imagine the operation yields the following result:\n\n| dk   | l3   | d8   | 23   |\n| ---- | ---- | ---- | ---- |\n| al   | d2   | so   | d1   |\n| cn   | kd   | 4m   | n3   |\n| 32   | g9   | kw   | hr   |\n\nMatrix multiplication: lets say we have:\n\n| 2    | 3    | 1    | 1    |      | c0   |\n| ---- | ---- | ---- | ---- | ---- | ---- |\n| 1    | 3    | 3    | 1    |      | c1   |\n| 1    | 2    | 2    | 3    |      | c2   |\n| 3    | 1    | 1    | 2    |      | c3   |\n\nrow 1 * c0 + row 2 * c1 + row 3 * c2 + row 4 + c3 = \n\nReordering bytes trough mixcolboxes \n\n#### Add round key (again)\n\nRemember how we produced those circular keys at the beginning with our initial key and Rijndael's key schedule? This is where we begin to employ them. We add the first round key we obtained to the result of our mixed columns\n\nBut that not all it doesn't  stop there. At the start it was mentioned that there are different sizes that can be applied. Either 128, 192 or 256 bits. When we use a 128 bits key. The encryption will use nine round after each other. When a 192 bit key is used this will be eleven rounds. Wen a 256 bit key is used there will be 14 rounds. \n\n**To make things clearer, the entire AES encryption process goes:**\n\n*Key expansion*\n\n*Add round key*\n\n*Byte substitution* (provides confusion)\n\n*Shift rows*  (provides diffusion)\n\n*Mix columns* (provides diffusion)\n\n*Add round key*      \n\n*x 9, 11 or 14 times, depending on whether the key is 128, 192 or 256-bit*\n\n*Byte substitution*\n\n*Shift rows*\n\n*Add round key*\n\nAfter the data has gone through this complicated procedure, my initial \"I want to get a good for this semester hihi\" becomes \"38kwo3jgnsuwfhc6pncxl35vs\"\n\n### Decrypting AES\n\nIf we start with our encrypted result of **“38kwo3jgnsuwfhc6pncxl35vs”** and **apply the inverse of each encryption step**, it starts with the inverse round key, then the inverse shift rows, and the inverse byte substitution, before going into the inverse of the 9, 11 or 14 rounds. **It looks like this:**\n\n“38kwo3jgnsuwfhc6pncxl35vs”\n\n*Inverse add round key*\n\n*Inverse shift rows*\n\n*Inverse byte substitution*\n\n*Inverse add round key*\n\n*Inverse mix columns*\n\n*Inverse shift rows*\n\n*Inverse byte substitution*     \n\n*x 9, 11 or 14 times, depending on whether the key is 128,192 or 256-bit* \n\n*Inverse add round key*\n\nAfter this decryption process, we end up with our original message again: **“I want to get a good for this semester hihi”**\n\n```\nfunction AESencrypt(plaintext, key) {\n  \n  blocks := divideIntoBlocks(plaintext);\n  roundKeys = getRoundKeys(key)\n  for (block in blocks) {\n    \u002F\u002Ffirst round\n    addRoundKey(roundKeys[0], block);\n    \u002F\u002Fintermediate rounds\n    for (8, 10 or 12 rounds) {\n      subBytes(block);\n      shiftRows(block);\n      mixColumns(block);\n      addRoundKey(roundKeys[..], block);\n    }\n    \u002F\u002Flast round\n    subBytes(block);\n    shiftRows(block);\n    addRoundKey(roundKeys[numRounds - 1], block);\n  }\n  ciphertext := reassemble(blocks);\n  return ciphertext;\n}\n```\n\n\u003Ca href=\"\u002Fimages\u002Fprojects\u002Fminor\u002Frounds.png\" target=\"_blank\" rel=\"some text\"\u003E\n  \u003Cimg width=\"80%\" src=\"\u002Fimages\u002Fprojects\u002Fminor\u002Frounds.png\" alt=\"aes\"\u002F\u003E\n\u003C\u002Fa\u003E\n\n\u003Ca href=\"\u002Fimages\u002Fprojects\u002Fminor\u002Ffuntion_for_rounds.png\" target=\"_blank\" rel=\"some text\"\u003E\n  \u003Cimg width=\"80%\" src=\"\u002Fimages\u002Fprojects\u002Fminor\u002Ffunction_for_rounds.png\" alt=\"aes\"\u002F\u003E\n\u003C\u002Fa\u003E\n\n \n";aa.readingTime="15 min read";aa.twitterShareUrl="https:\u002F\u002Ftwitter.com\u002Fintent\u002Ftweet";return {data:[{project:aa,_img:aX}],fetch:{"data-v-312258fc:0":{toastOptions:{duration:2000,theme:"bubble"},currentlyActiveToc:"",observer:aY,observerOptions:{root:void 0,threshold:0},project:aa,_img:aX}},mutations:[["setItem",{item:aY,id:ab,resource:"comments"}]]}}("element","text","td","\n","p","th","tr","a","li","em","true",-1,"span","icon","icon-link","table","thead","tbody","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","e","t","ul","h4","o","1","_blank","d2",2,"h2","nuxt-link","some","\n  ","img","80%","h3","s","3","strong",3,"aes","I","n","w","r","Add round key","2","https","g","h","i","m","dj","Shift rows","Inverse add round key",{},"minor_https","HTTPS","encryption","Encryption","http-with-ssltls","Http with SSL\u002FTLS","open-wifi-monitoring-traffic","Open Wifi monitoring traffic","work-moniting-traffic","Work moniting traffic","ciphersuite","CipherSuite","commonly-used-symmetric-encryption-algorithms-include","Commonly used symmetric encryption algorithms include:","aes---advanced-encryption-standard","AES - Advanced Encryption Standard","how-does-aeswork","How does AESwork","decrypting-aes","Decrypting AES","h1","\u002Fimages\u002Fprojects\u002Fminor\u002FHTTPS.gif","\u002Fimages\u002Fprojects\u002Fminor\u002Fprocess.png","Key expansion","b","s5","9f","as","ls","sl","l2","0s","1k","ao","l1","dn","lf","54","6l","19","mn","\u002Fimages\u002Fprojects\u002Fminor\u002Fs-box-table.png","Mix columns","Byte substitution","“38kwo3jgnsuwfhc6pncxl35vs”","Inverse shift rows","Inverse byte substitution","\u002Fimages\u002Fprojects\u002Fminor\u002Frounds.png",{},null)));